# 新版计划

## 问题

1.1 及之前版本所有操作的二进制、十六进制，都是操作的字符串，
比如对 `'abc'` 就会转化成十六进制字符串 `'616263'` 再转化成二进制字符串 `'11000010110001001100011'`。

但是经过思考，发现并不应该在字符串层面进行操作，
尤其是二进制字符串，其实应该是个二进制串，也就是实际上内存中存储的形式。

这样虽然不便于肉眼识别，但却可以大量节省内存。 
尤其是用于对图片对读取和运算。

我们知道，`file_get_contents()` 函数只有在文件量级很大的时候才会发生内存溢出，
但如果在读取之后转换为字符串的形式（乱码），往往转换很小一部分就会发生内存溢出。

这就是因为字符串形式的 `'1'` 和内存中存储的比特 `1` 占用的空间区别很大。
比特 `1` 只占用 1 个比特大小的内存（即1位），但字符串 `'1'` 可能就需要一个字符。
```
1 字符 = 2 字节 = 2 Byte = 2 B
1 B   =  8 位  = 8 Bit

即：
'1' 的大小为 2B = 2 * 8 = 16 Bit
```

这么换算下来，一个二进制字符串的操作，大约浪费二进制位操作的 8 倍大小的内存。

## 解决方案

> 中心思想：尽量直接操作位，如果是字符串形式，就先转换为二进制位的形式

1. 字符串转化为二进制位
    1.  字符串转化为十六进制数组
    2.  遍历数组中的每一个元素，进行补位
    3.  将数组拼接为十六进制字符串
    4.  将十六进制字符串转换为二进制位的形式
        ```injectablephp
        pack('H*',$十六进制字符串)
        ```
2. 文件通过 `file_get_contents()` 读取出来就是二进制位的形式，所以字符串输出之后才会出现乱码
    1. 读取文件为位形式的字符串
    2. 直接对此位字符串进行操作
